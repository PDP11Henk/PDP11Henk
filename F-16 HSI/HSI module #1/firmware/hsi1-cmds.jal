-- -----------------------------------------------------------------------------
-- Title:  HSI (Horizontal Situation Indicator) control module #1
--         with USB and PHCC DOA connection using the Microchip PIC18F4550
--
-- Submodule: hsi1-cmds
--
--    this module contains the processing of all "HSI1" commands.


-- -----------------------------------------------------------------------------
-- processCommand - process received command packet
-- -----------------------------------------------------------------------------

var word loadOffset
var word loadOffsetLsb


procedure processCommand() is
  var byte IDbyte
  var sword delta

  case (commandCode) of
      CMD_BRG_Q1 : block
              bearingNewPos = word(commandData)
              bearingUpdate = TRUE
          end block
      CMD_BRG_Q2 : block
              bearingNewPos = word(commandData) + 256
              bearingUpdate = TRUE
          end block
      CMD_BRG_Q3 : block
              bearingNewPos = word(commandData) + 512
              bearingUpdate = TRUE
          end block
      CMD_BRG_Q4 : block
              bearingNewPos = word(commandData) + 768
              bearingUpdate = TRUE
          end block
--
      CMD_HDG_Q1 : block
              headingNewPos = word(commandData)
              headingUpdate = TRUE
          end block
      CMD_HDG_Q2 : block
              headingNewPos = word(commandData) + 256
              headingUpdate = TRUE
          end block
      CMD_HDG_Q3 : block
              headingNewPos = word(commandData) + 512
              headingUpdate = TRUE
          end block
      CMD_HDG_Q4 : block
              headingNewPos = word(commandData) + 768
              headingUpdate = TRUE
          end block
--
      CMD_MLS_1Q1 : block
              if ( (milesLowPowerEnabled == FALSE)    |
                   ( (milesLowPowerEnabled == TRUE) &
                     (MLSSHUTTER == SHUTTER_HIDDEN) ) ) then
                  miles1NewPos = word(commandData)
                  miles1Update = TRUE
              end if
          end block
      CMD_MLS_1Q2 : block
              if ( (milesLowPowerEnabled == FALSE)    |
                   ( (milesLowPowerEnabled == TRUE) &
                     (MLSSHUTTER == SHUTTER_HIDDEN) ) ) then
                  miles1NewPos = word(commandData) + 256
                  miles1Update = TRUE
              end if
          end block
      CMD_MLS_1Q3 : block
              if ( (milesLowPowerEnabled == FALSE)    |
                   ( (milesLowPowerEnabled == TRUE) &
                     (MLSSHUTTER == SHUTTER_HIDDEN) ) ) then
                  miles1NewPos = word(commandData) + 512
                  miles1Update = TRUE
              end if
          end block
      CMD_MLS_1Q4 : block
              if ( (milesLowPowerEnabled == FALSE)    |
                   ( (milesLowPowerEnabled == TRUE) &
                     (MLSSHUTTER == SHUTTER_HIDDEN) ) ) then
                  miles1NewPos = word(commandData) + 768
                  miles1Update = TRUE
              end if
          end block
--
      CMD_MLS_2Q1 : block
              if ( (milesLowPowerEnabled == FALSE)    |
                   ( (milesLowPowerEnabled == TRUE) &
                     (MLSSHUTTER == SHUTTER_HIDDEN) ) ) then
                  miles2NewPos = word(commandData)
                  miles2Update = TRUE
              end if
          end block
      CMD_MLS_2Q2 : block
              if ( (milesLowPowerEnabled == FALSE)    |
                   ( (milesLowPowerEnabled == TRUE) &
                     (MLSSHUTTER == SHUTTER_HIDDEN) ) ) then
                  miles2NewPos = word(commandData) + 256
                  miles2Update = TRUE
              end if
          end block
      CMD_MLS_2Q3 : block
              if ( (milesLowPowerEnabled == FALSE)    |
                   ( (milesLowPowerEnabled == TRUE) &
                     (MLSSHUTTER == SHUTTER_HIDDEN) ) ) then
                  miles2NewPos = word(commandData) + 512
                  miles2Update = TRUE
              end if
          end block
      CMD_MLS_2Q4 : block
              if ( (milesLowPowerEnabled == FALSE)    |
                   ( (milesLowPowerEnabled == TRUE) &
                     (MLSSHUTTER == SHUTTER_HIDDEN) ) ) then
                  miles2NewPos = word(commandData) + 768
                  miles2Update = TRUE
              end if
          end block
--
      CMD_MLS_3Q1 : block
              if ( (milesLowPowerEnabled == FALSE)    |
                   ( (milesLowPowerEnabled == TRUE) &
                     (MLSSHUTTER == SHUTTER_HIDDEN) ) ) then
                  miles3NewPos = word(commandData)
                  miles3Update = TRUE
              end if
          end block
      CMD_MLS_3Q2 : block
              if ( (milesLowPowerEnabled == FALSE)    |
                   ( (milesLowPowerEnabled == TRUE) &
                     (MLSSHUTTER == SHUTTER_HIDDEN) ) ) then
                  miles3NewPos = word(commandData) + 256
                  miles3Update = TRUE
              end if
          end block
      CMD_MLS_3Q3 : block
              if ( (milesLowPowerEnabled == FALSE)    |
                   ( (milesLowPowerEnabled == TRUE) &
                     (MLSSHUTTER == SHUTTER_HIDDEN) ) ) then
                  miles3NewPos = word(commandData) + 512
                  miles3Update = TRUE
              end if
          end block
      CMD_MLS_3Q4 : block
              if ( (milesLowPowerEnabled == FALSE)    |
                   ( (milesLowPowerEnabled == TRUE) &
                     (MLSSHUTTER == SHUTTER_HIDDEN) ) ) then
                  miles3NewPos = word(commandData) + 768
                  miles3Update = TRUE
              end if
          end block
--
      CMD_MILSHUTR : block
              if (commandData == 0) then
                  MLSSHUTTER = SHUTTER_VISIBLE
                  if (milesLowPowerEnabled == TRUE) then
                      -- coils at low power when bar is visible
                      setMilesSynchrosLowPower()
                  end if
              end if
              if (commandData == 1) then
                  MLSSHUTTER = SHUTTER_HIDDEN
              end if
          end block
--
      CMD_WTCHDOG_DIS : block
              disableWatchdog()
          end block
      CMD_WTCHDOG_ENA : block
              if ((commandData & 0x3F) == 0x00) then
                  -- set default timeout value
                  wtchdogDelayValue = WTCHDOG_DFLT_TIMEOUT
              else
                  wtchdogDelayValue = word(commandData & 0x3F)
              end if
              if ((commandData & 0xC0) == 0x80) then
                  -- enable watchdog
                  set_delay(COMM_WATCHDOG_SLOT, wtchdogDelayValue)
                  enableWatchdog()
              end if
              if ((commandData & 0xC0) == 0x00) then
                  -- disable watchdog
                  disableWatchdog()
              end if
          end block
--
      CMD_DIAGMODE : block
              if (flashRate != DOA_RESET_RATE) then
                  -- do not accept DIAG commands during DOA power-up
                  setDiagLEDmode(commandData)
              end if
          end block
--
      CMD_USROUT_A : block
              if (commandData == 0) then  USEROUTA = 0 end if
              if (commandData == 1) then  USEROUTA = 1 end if
          end block
      CMD_USROUT_B : block
              if (commandData == 0) then  USEROUTB = 0 end if
              if (commandData == 1) then  USEROUTB = 1 end if
          end block
--
      -- load base angle offsets (in 10-bit accuracy)
      -- NOTE: LSB value must be set *before* MSB value!
      CMD_LD_OFFS_L : block
              loadOffsetLsb = word(commandData)
          end block
      CMD_LD_OFFS_H : block
              loadOffset = word(commandData & 0x03) << 8
              loadOffset = loadOffset + loadOffsetLsb
          end block
--
      CMD_LOAD_BRG : block
              if ((commandData & 0x01) == 0x01) then
                  brgS1Offset = loadOffset
              elsif ((commandData & 0x02) == 0x02) then
                  brgS2Offset = loadOffset
              elsif ((commandData & 0x04) == 0x04) then
                  brgS3Offset = loadOffset
              else
                  -- reject: wrong bitmask
              end if
          end block
--
      CMD_LOAD_HDG : block
              if ((commandData & 0x01) == 0x01) then
                  hdgS1Offset = loadOffset
              elsif ((commandData & 0x02) == 0x02) then
                  hdgS2Offset = loadOffset
              elsif ((commandData & 0x04) == 0x04) then
                  hdgS3Offset = loadOffset
              else
                  -- reject: wrong bitmask
              end if
          end block
--
      CMD_LOAD_RNG : block
              if ((commandData & 0x01) == 0x01) then
                  miles1OffsetX = loadOffset
              elsif ((commandData & 0x02) == 0x02) then
                  miles1OffsetY = loadOffset
              elsif ((commandData & 0x04) == 0x04) then
                  miles2OffsetX = loadOffset
              elsif ((commandData & 0x08) == 0x08) then
                  miles2OffsetY = loadOffset
              elsif ((commandData & 0x10) == 0x10) then
                  miles3OffsetX = loadOffset
              elsif ((commandData & 0x20) == 0x20) then
                  miles3OffsetY = loadOffset
              else
                  -- reject: wrong bitmask
              end if
          end block
--
--
      CMD_BRG_S1 : block
              bearingAmplitudeS1 = word(255 - commandData) << 2
          end block
      CMD_BRG_S2 : block
              bearingAmplitudeS2 = word(255 - commandData) << 2
          end block
      CMD_BRG_S3 : block
              bearingAmplitudeS3 = word(255 - commandData) << 2
          end block
--
      CMD_BRG_POL : block
              --  +--7--+--6--+--5--+--4--+--3--+--2--+--1--+--0--+
              --  |     |     |     |     |     |  S3 |  S2 |  S1 |
              --  +-----+-----+-----+-----+-----+-----+-----+-----+
              --                                  pol   pol   pol
              --
              --  Bits 0, 1, and 2 set the polarity of S1, S2, and S3
              --  respectively of the BEARING synchro.
              --  Bits 3-4-5-6-7 are ignored.

              bearingPolarityS1 = (commandData & 0x01)
              bearingPolarityS2 = (commandData & 0x02) >> 1
              bearingPolarityS3 = (commandData & 0x04) >> 2
              if (setpointsToDACsActive == FALSE) then
                  setpointsToDACsActive = TRUE
                  bearingSetpoint(bearingAmplitudeS1, bearingAmplitudeS2,
                                  bearingAmplitudeS3, bearingPolarityS1,
                                  bearingPolarityS2,  bearingPolarityS3 )
              end if
          end block
--
      CMD_HDG_S1 : block
              headingAmplitudeS1 = word(255 - commandData) << 2
          end block
      CMD_HDG_S2 : block
              headingAmplitudeS2 = word(255 - commandData) << 2
          end block
      CMD_HDG_S3 : block
              headingAmplitudeS3 = word(255 - commandData) << 2
          end block
--
      CMD_HDG_POL : block
              --  +--7--+--6--+--5--+--4--+--3--+--2--+--1--+--0--+
              --  |     |     |     |     |     |  S3 |  S2 |  S1 |
              --  +-----+-----+-----+-----+-----+-----+-----+-----+
              --                                  pol   pol   pol
              --
              --  Bits 0, 1, and 2 set the polarity of S1, S2, and S3
              --  respectively of the HEADING synchro.
              --  Bits 3-4-5-6-7 are ignored.

              headingPolarityS1 = (commandData & 0x01)
              headingPolarityS2 = (commandData & 0x02) >> 1
              headingPolarityS3 = (commandData & 0x04) >> 2
              if (setpointsToDACsActive == FALSE) then
                  setpointsToDACsActive = TRUE
                  headingSetpoint(headingAmplitudeS1, headingAmplitudeS2,
                                  headingAmplitudeS3, headingPolarityS1,
                                  headingPolarityS2,  headingPolarityS3 )
              end if
          end block
--
      CMD_MLS_1X : block
              miles1AmplitudeX = word(255 - commandData) << 2
          end block
      CMD_MLS_1Y : block
              miles1AmplitudeY = word(255 - commandData) << 2
          end block
--
      CMD_M1_POL : block
              --  +--7--+--6--+--5--+--4--+--3--+--2--+--1--+--0--+
              --  |     |     |     |     |     |     |  Y  |  X  |
              --  +-----+-----+-----+-----+-----+-----+-----+-----+
              --                                        pol   pol
              --
              --  Bits 0 and 1 set the polarity of X and Y
              --  respectively of the MILES units synchro.
              --  Bits 2-3-4-5-6-7 are ignored.

              miles1PolarityX = (commandData & 0x01)
              miles1PolarityY = (commandData & 0x02) >> 1
              if (setpointsToDACsActive == FALSE) then
                  setpointsToDACsActive = TRUE
                  miles1Setpoint(miles1AmplitudeX, miles1AmplitudeY,
                                 miles1PolarityX,  miles1PolarityY )
              end if
          end block
--
      CMD_MLS_2X : block
              miles2AmplitudeX = word(255 - commandData) << 2
          end block
      CMD_MLS_2Y : block
              miles2AmplitudeY = word(255 - commandData) << 2
          end block
--
      CMD_M2_POL : block
              --  +--7--+--6--+--5--+--4--+--3--+--2--+--1--+--0--+
              --  |     |     |     |     |     |     |  Y  |  X  |
              --  +-----+-----+-----+-----+-----+-----+-----+-----+
              --                                        pol   pol
              --
              --  Bits 0 and 1 set the polarity of X and Y
              --  respectively of the MILES tens synchro.
              --  Bits 2-3-4-5-6-7 are ignored.

              miles2PolarityX = (commandData & 0x01)
              miles2PolarityY = (commandData & 0x02) >> 1
              if (setpointsToDACsActive == FALSE) then
                  setpointsToDACsActive = TRUE
                  miles2Setpoint(miles2AmplitudeX, miles2AmplitudeY,
                                 miles2PolarityX,  miles2PolarityY )
              end if
          end block
--
      CMD_MLS_3X : block
              miles3AmplitudeX = word(255 - commandData) << 2
          end block
      CMD_MLS_3Y : block
              miles3AmplitudeY = word(255 - commandData) << 2
          end block
--
      CMD_M3_POL : block
              --  +--7--+--6--+--5--+--4--+--3--+--2--+--1--+--0--+
              --  |     |     |     |     |     |     |  Y  |  X  |
              --  +-----+-----+-----+-----+-----+-----+-----+-----+
              --                                        pol   pol
              --
              --  Bits 0 and 1 set the polarity of X and Y
              --  respectively of the MILES hundreds synchro.
              --  Bits 2-3-4-5-6-7 are ignored.

              miles3PolarityX = (commandData & 0x01)
              miles3PolarityY = (commandData & 0x02) >> 1
              if (setpointsToDACsActive == FALSE) then
                  setpointsToDACsActive = TRUE
                  miles3Setpoint(miles3AmplitudeX, miles3AmplitudeY,
                                 miles3PolarityX,  miles3PolarityY )
              end if
          end block
--
      CMD_MLS_LOWPWR : block
              if (commandData == 0) then  milesLowPowerEnabled = FALSE end if
              if (commandData == 1) then
                  milesLowPowerEnabled = TRUE
                  -- check whether RANGE INVALID bar is visible
                  if (MLSSHUTTER == SHUTTER_VISIBLE) then
                      -- coils at low power when bar visible
                      setMilesSynchrosLowPower()
                  end if
              end if
          end block
--
-- USB test
      CMD_IDENTIFY  : block
              -- double check that USB is the COM port in use!
              if (commPort == USE_USB) then
                  usb_serial_data = "H"
                  usb_serial_data = "S"
                  usb_serial_data = "I"
                  usb_serial_data = "#"
                  usb_serial_data = "1"
                  usb_serial_data = " "
                  usb_serial_data = "v"
                  usb_serial_data = "0" + MAJOR_VERSION
                  usb_serial_data = "."
                  usb_serial_data = "0" + MINOR_VERSION
                  usb_serial_data = " "
                  usb_serial_data = "$"
                  IDbyte = ((HSI_DEVICE_ADDR_1 >> 4) & 0x0F) + "0"
                  if (IDbyte > "9") then IDbyte = IDbyte + 7  end if
                  usb_serial_data = IDbyte
                  IDbyte = (HSI_DEVICE_ADDR_1 & 0x0F) + "0"
                  if (IDbyte > "9") then IDbyte = IDbyte + 7  end if
                  usb_serial_data = IDbyte
                  usb_serial_data = 13                        -- add CR
                  usb_serial_data = 10                        -- add LF
              end if
          end block
-- USB debug
      CMD_USB_DEBUG : block
              -- double check that USB is the COM port in use!
              if (commPort == USE_USB) then
                  if (commandData == "N") then
                      USBdebugEnabled = FALSE
                  elsif (commandData == "Y") then
                      USBdebugEnabled = TRUE
                  end if
              end if
          end block

      -- ignore everything else
      otherwise block
              ; do nothing - reject
          end block
  end case
end procedure

