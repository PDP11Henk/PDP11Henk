-- -----------------------------------------------------------------------------
-- Title:  HSI (Horizontal Situation Indicator) control modules (#1 and #2)
--         with USB and PHCC DOA connection using the Microchip PIC18F4550
--
-- Submodule: hsi-usb
--
--    this module contains the (polling) USB data byte reception and the state
--    machine to process a complete USB "message".
--    Output: - USBcmdReceived : flag to indicate valid data packet received
--            - USBrxByte1     : first data byte
--            - USBrxByte2     : second data byte

include usb_serial


var byte   USB_RXstate             -- USB protocol RX byte state
const byte USB_STATE_IDLE     = 0  -- USB receiver state machine state
const byte USB_STATE_DATA     = 1
const byte USB_STATE_RESET    = 2
var byte   USBrxByte1              -- USB first received byte
var byte   USBrxByte2              -- USB second received byte
var byte   USBcmdReceived          -- flag: USB valid command received
var byte   USBdebugEnabled         -- flag: output USB debug info


-- -----------------------------------------------------------------------------
-- USBmsgStateControl - determine action based on received USB data byte
-- -----------------------------------------------------------------------------
-- State machine states:
--   IDLE : awaiting command code: the received byte is the first data byte
--   DATA : awaiting command data: the received byte is the second data byte
-- -----------------------------------------------------------------------------

-- "!" : USB receive data state machine in illegal state (should never occur)
-- "#" : invalid command number
-- "x" : "disable watchdog" command received
-- "-" : following 2 characters are hexadecimal command (first byte)
-- "=" : following 2 characters are hexadecimal data (second byte)

const BYTE ASCII_CR = 0x0D
const BYTE ASCII_LF = 0x0A
const BYTE nibble2hex[] = "0123456789ABCDEF"



procedure initUSB() is
    USBcmdReceived  = FALSE
    USBdebugEnabled = FALSE
    USB_RXstate     = USB_STATE_IDLE      -- USB RX state machine initial state
end procedure



procedure sendUSBChar(byte in token) is
    if (USBdebugEnabled == TRUE) then
        -- print ASCII character
        usb_serial_data = token
    end if
end procedure



procedure sendUSBByte(byte in dataByte) is
    if (USBdebugEnabled == TRUE) then
        usb_serial_data = nibble2hex[0x0F & (dataByte>>4)]
        usb_serial_data = nibble2hex[0x0F & (dataByte)]
    end if
end procedure


-- =============================================================================
--procedure debugPrintText(byte in text[]) is
--  var byte ix, token
--
--    if (USBdebugEnabled == TRUE) then
--        -- print ASCII string until "!"
--        ix = 0
--        while (text[ix] != "!") loop
--            usb_serial_data = text[ix]
--            ix = ix + 1
--        end loop
--    end if
--end procedure


--procedure debugPrintNewLine() is
--    if (USBdebugEnabled == TRUE) then
--        -- print ASCII CR & LF
--        usb_serial_data = ASCII_CR
--        usb_serial_data = ASCII_LF
--    end if
--end procedure


--procedure debugPrintByte(byte in dataByte) is
--    sendUSBByte(dataByte)
--end procedure


--procedure debugPrintChar(byte in token) is
--    sendUSBChar(token)
--end procedure


--procedure debugPrintWord(word in dataWord) is
--  var byte upper, lower
--
--    if (USBdebugEnabled == TRUE) then
--        upper = byte(dataWord >> 8)
--        sendUSBByte(upper)
--        lower = byte(dataWord & 0x00FF)
--        sendUSBByte(lower)
--    end if
--end procedure
-- =============================================================================



procedure USBmsgStateControl(byte in rxbyte) is
  if (wtchdogState == WTCHDOG_ENABLED) then
     set_delay(COMM_WATCHDOG_SLOT, wtchdogDelayValue)     -- protocol watchdog
  end if
  case (USB_RXstate) of
     USB_STATE_IDLE :
        block
           if (rxbyte <= CMD_USB_DEBUG) then
              USBrxByte1 = rxbyte
              if (USBrxByte1 == CMD_WTCHDOG_DIS) then
                 -- special case: NO data byte will follow!
                 wtchdogState = WTCHDOG_DISABLED
                 sendUSBChar("x")
              else
                 USB_RXstate = USB_STATE_DATA
                 sendUSBChar("-")
                 sendUSBByte(USBrxByte1)
              end if
           else
              sendUSBChar("#")
              sendUSBByte(USBrxByte1)
           end if
        end block

     USB_STATE_DATA :
        block
           -- store data & accept command
           USBrxByte2     = rxbyte
           USBcmdReceived = TRUE
           USB_RXstate    = USB_STATE_IDLE
           sendUSBChar("=")
           sendUSBByte(USBrxByte2)
        end block

    USB_STATE_RESET :
          block
             -- this state could be reached if the watchdog is expired and an
             -- interrupt is received while the watchdog resets variables.
          end block

    otherwise
        block
           USB_RXstate = USB_STATE_IDLE   -- ?? --> reset
           sendUSBChar("!")
        end block
  end case
end procedure



-- -----------------------------------------------------------------------------
-- handleUSBcommunication - await (non-blocking) for character received
--                          then process it in state machine
-- -----------------------------------------------------------------------------
-- The USB interrupt service routine is polled and checked if a character is
-- received. When a character is received the LED is toggled. As the received
-- character can be a command character or a data character belonging to a
-- command, a state machine decides what to do.
-- -----------------------------------------------------------------------------
procedure handleUSBcommunication is

var byte msgByte

  msgByte = 0
  usb_serial_flush()                 ; poll USB ISR function, serve USB requests
  if (usb_serial_read(msgByte)) then       ; check received data & process it
    USBmsgStateControl(msgByte)            ; let state machine decide what to do
  end if
end procedure

