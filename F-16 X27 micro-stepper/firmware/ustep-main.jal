-- -----------------------------------------------------------------------------
-- Title:
-- microStepper control module (based on Guy Carpenter's design) with USB and
-- PHCC DOA connection using the Microchip PIC18F2550. See links
-- https://guy.carpenter.id.au/gaugette/2017/04/29/switecx25-quad-driver-tests/
-- and https://github.com/clearwater/SwitecX25/issues/15
--
-- Author: Henk Gooijen
--
-- Compiler: 2.5r1
--
-- Description:
-- microStepper control module is the firmware to control 4 stepper motors,
-- such as the X27 steppers using the AX1201728SG microstepper controller IC.
--
-- Notes:
-- # File creation date/time: 24 July 2018.
--   19-02-2019 : board and firmware finally tested. Needed to swap M2 and M3
--                CLKMOT and DIRMOT definitions to match the silkscreen printing
--                on the PCB!
--   20-02-2019 : separate default acc/dec table for each motor (see ustep-x27).
--   21-02-2019 : "uploadable" acc/dec table that subsequently can be selected,
--                for a user-defined acc/dec profile.
--   22-02-2019 : when a home sensor input is defined you can also specify what
--                the sensor active level is (0 or 1).
--
-- -----------------------------------------------------------------------------
const byte MAJOR_VERSION = 1            -- hardware PCB version 1
const byte MINOR_VERSION = 1            -- software version 1

include 18f2550                         -- target PIC processor


-- The program assumes that a 20 MHz crystal is connected to pins OSC1 and OSC2.
-- (unspecified configuration bits may cause a different frequency!)
pragma target clock 48_000_000          -- OSC frequency used by delay routines
--
-- -----------------------------------------------------------------------------
-- ** fuses
-- -----------------------------------------------------------------------------
--
pragma target PLLDIV        P5          -- divide by 5 - 20 MHz_INPUT
pragma target CPUDIV        P2          -- OSC1_OSC2_SRC_1_96MHZ_PLL_SRC_2
--
-- *** defines for compiler version 2.4o
--pragma target USBPLL        F48MHZ      -- CLOCK_SRC_FROM_96MHZ_PLL_2
--pragma target WDT           DISABLED    -- no watchdog
--
-- *** defines for compiler version 2.5r1
pragma target USBDIV        P2          -- CLOCK_SRC_FROM_96MHZ_PLL_2
pragma target WDT           CONTROL     -- no watchdog
--
pragma target OSC           HS_PLL
pragma target FCMEN         DISABLED
pragma target IESO          DISABLED
pragma target PWRTE         ENABLED     -- power up timer
pragma target VREGEN        ENABLED     -- USB voltage regulator
pragma target BROWNOUT      ENABLED     -- brownout detection
pragma target WDTPS         P32K        -- watch dog saler setting
pragma target PBADEN        DIGITAL     -- analog input port<0..4>
pragma target LPT1OSC       LOW_POWER   -- low power timer 1
pragma target MCLR          EXTERNAL    -- master reset on RE3
pragma target STVR          DISABLED    -- reset on stack over/under flow
pragma target LVP           DISABLED    -- no low-voltage programming
pragma target DEBUG         DISABLED    -- background debugging
pragma target CP0           DISABLED    -- code block 0 not protected
pragma target CP1           DISABLED    -- code block 1 not protected
pragma target CP2           DISABLED    -- code block 2 not protected
pragma target CP3           DISABLED    -- code block 3 not protected
pragma target CPB           DISABLED    -- bootblock code not write protected
pragma target CPD           DISABLED    -- eeprom code not write protected
pragma target WRT0          DISABLED    -- table writeblock 0 not protected
pragma target WRT1          DISABLED    -- table write block 1 not protected
pragma target WRT2          DISABLED    -- table write block 2 not protected
pragma target WRT3          DISABLED    -- table write block 3 not protected
pragma target WRTB          DISABLED    -- bootblock not write protected
pragma target WRTD          DISABLED    -- eeprom not write protected
pragma target WRTC          DISABLED    -- config not write protected
pragma target EBTR0         DISABLED    -- table read block 0 not protected
pragma target EBTR1         DISABLED    -- table read block 1 not protected
pragma target EBTR2         DISABLED    -- table read block 2 not protected
pragma target EBTR3         DISABLED    -- table read block 3 not protected
pragma target EBTRB         DISABLED    -- boot block not protected



-- =============================================================================
-- ** Hardware declarations
-- =============================================================================
--
--  I/O pin definitions
alias  SENSOR1     is pin_A0        -- "home" sensor motor #1
alias  USB_DOA     is pin_A1        -- USB/DOA selection jumper
alias  SENSOR2     is pin_A2        -- "home" sensor motor #2
alias  SENSOR3     is pin_A3        -- "home" sensor motor #3
alias  DIAGLED     is pin_A4        -- diagnostic on-board LED
alias  DOA_DATA    is pin_A5        -- PHCC DOA bus data signal

alias  CLKMOT2     is pin_B0        -- clock pulse motor #2
alias  DIRMOT2     is pin_B1        -- direction motor #2
alias  DOA_CLOCK   is pin_B2        -- PHCC DOA bus clock signal
alias  CLKMOT3     is pin_B3        -- clock pulse motor #3
alias  DIRMOT3     is pin_B4        -- direction motor #3
alias  STPRRESET   is pin_B5        -- stepper motor IC reset
alias  DIRMOT1     is pin_B6        -- direction motor #1
alias  CLKMOT1     is pin_B7        -- clock pulse motor #1

alias  SENSOR4     is pin_C0        -- "home" sensor motor #4
alias  MOTENABLE   is pin_C1        -- L293 motor drivers output enable
alias  VsenseIN    is pin_C2        -- USB host voltage sense
--     USBvoltRef  is pin_C3        -- USB voltage reference
--     USBdataN    is pin_C4        -- USB data -
--     USBdataP    is pin_C5        -- USB data +
alias  DIRMOT4     is pin_C6        -- direction motor #4
alias  CLKMOT4     is pin_C7        -- clock pulse motor #4

--  I/O direction
pin_A0_direction    = input
pin_A1_direction    = input
pin_A2_direction    = input
pin_A3_direction    = input
pin_A4_direction    = output
pin_A5_direction    = input

pin_B0_direction    = output
pin_B1_direction    = output
pin_B2_direction    = input
pin_B3_direction    = output
pin_B4_direction    = output
pin_B5_direction    = output
pin_B6_direction    = output
pin_B7_direction    = output

pin_C0_direction    = input
pin_C1_direction    = output
pin_C2_direction    = input
-- pin_C3_direction = input
-- pin_C4_direction = input
-- pin_C5_direction = input
pin_C6_direction    = output
pin_C7_direction    = output



-- =============================================================================
-- ** constants and variables: DOA and USB protocol receiver routines
-- =============================================================================

const byte USTEP_ADDR            = 0x75    -- microStepper ASCII-u PHCC ADDRESS
const word USB_SERIAL_VENDOR_ID  = 0x04D8  -- Microchip
const word USB_SERIAL_PRODUCT_ID = 0x000A  -- CDC

var byte   commandCode             -- received command code (DOA / USB) sub
var byte   commandData             -- received command data (DOA / USB) sub



-- =============================================================================
-- ** constants and variables: timer definition, diagnostic LED and watchdog
-- =============================================================================

-- timer slots
const HEARTBEAT_SLOT       = 0     -- timer slot for flashing DIAG LED
const COMM_WATCHDOG_SLOT   = 1     -- DOA & USB communication watchdog timer
const DELAY_SLOTS          = 2     -- number of needed timer slots
const timer0_isr_rate      = 1000  -- set system interval time = 1 ms

-- diagnostic LED
const byte LED_ON  = 0             -- LED connected to common +5, so:
const byte LED_OFF = 1             -- inverted logic: 0::on // 1::off

-- diagnostic LED usage definitions
const byte DIAGLED_OFF       = 0   -- DIAG LED mode :: always OFF
const byte DIAGLED_ON        = 1   -- DIAG LED mode :: always ON
const byte DIAGLED_HEARTBEAT = 2   -- DIAG LED flash at heartbeat rate
const byte DIAGLED_MSG_ACK   = 3   -- DIAG LED ON/OFF per received message
const byte DIAGLED_DOA_CHK   = 4   -- DIAG LED DOA protocol check error flag
var byte   diagLEDuse              -- current usage mode for the DIAG LED

-- variables for USB (dis)connection monitoring
var byte   chkUSBconnect           -- USB uses a startup (connection made)
var word   prevISRcounter          -- fast period connection check timer



-- =============================================================================
-- ** microStepper commands
--    (for DOA this is the sub-address, for USB this is the first message byte)
-- =============================================================================

const byte CMD_ABSPOS_0    = 0     -- absolute position range/value 000..255
const byte CMD_ABSPOS_1    = 1     -- absolute position range/value 256..511
const byte CMD_ABSPOS_2    = 2     -- absolute position range/value 512..767
const byte CMD_ABSPOS_3    = 3     -- absolute position range/value 768..1023
const byte CMD_ABSPOS_4    = 4     -- absolute position range/value 1024..1279
const byte CMD_ABSPOS_5    = 5     -- absolute position range/value 1280..1535
const byte CMD_ABSPOS_6    = 6     -- absolute position range/value 1536..1791
const byte CMD_ABSPOS_7    = 7     -- absolute position range/value 1792..2047
const byte CMD_ABSPOS_8    = 8     -- absolute position range/value 2048..2303
const byte CMD_ABSPOS_9    = 9     -- absolute position range/value 2304..2559
const byte CMD_ABSPOS_A    = 10    -- absolute position range/value 2560..2815
const byte CMD_ABSPOS_B    = 11    -- absolute position range/value 2816..3071
const byte CMD_ABSPOS_C    = 12    -- absolute position range/value 3072..3327
const byte CMD_ABSPOS_D    = 13    -- absolute position range/value 3328..3583
const byte CMD_ABSPOS_E    = 14    -- absolute position range/value 3584..3839
const byte CMD_ABSPOS_F    = 15    -- absolute position range/value 3840..4095
const byte CMD_ABSPOS_G    = 16    -- absolute position range/value 4096..4351
const byte CMD_ABSPOS_H    = 17    -- absolute position range/value 4352..4607
const byte CMD_ABSPOS_I    = 18    -- absolute position range/value 4608..4863
const byte CMD_ABSPOS_J    = 19    -- absolute position range/value 4864..5119
const byte CMD_ABSPOS_K    = 20    -- absolute position range/value 5120..5375
const byte CMD_ABSPOS_L    = 21    -- absolute position range/value 5376..5631
const byte CMD_ABSPOS_M    = 22    -- absolute position range/value 5632..5887
const byte CMD_ABSPOS_N    = 23    -- absolute position range/value 5888..6143
const byte CMD_ABSPOS_O    = 24    -- absolute position range/value 6144..6399

const byte CMD_ABS_SET_MOT = 25    -- specify motor ID for abs.pos
const byte CMD_MAX_RNG_MOT = 26    -- specify motor ID for maximum step range
const byte CMD_USR_DEF_MOT = 27    -- specify motor ID for user-def acc/dec tbl

const byte CMD_STEP_REL_M1 = 28    -- position stepper #1 relative
const byte CMD_STEP_REL_M2 = 29    -- position stepper #2 relative
const byte CMD_STEP_REL_M3 = 30    -- position stepper #3 relative
const byte CMD_STEP_REL_M4 = 31    -- position stepper #4 relative

const byte CMD_HOME_MOTOR1 = 32    -- stepper #1 to "home" position
const byte CMD_HOME_MOTOR2 = 33    -- stepper #2 to "home" position
const byte CMD_HOME_MOTOR3 = 34    -- stepper #3 to "home" position
const byte CMD_HOME_MOTOR4 = 35    -- stepper #4 to "home" position
const byte CMD_HOME_MOTORS = 36    -- combined previous 4 "home" commands

const byte CMD_USE_HOME_1  = 37    -- use "home" sensor & level for stepper #1
const byte CMD_USE_HOME_2  = 38    -- use "home" sensor & level for stepper #2
const byte CMD_USE_HOME_3  = 39    -- use "home" sensor & level for stepper #3
const byte CMD_USE_HOME_4  = 40    -- use "home" sensor & level for stepper #4

const byte CMD_VEL_TABLE   = 41    -- acc/dec velocity table (0:default, 1:user)

const byte CMD_MOTOR_PWR   = 42    -- L293 motor driver output ENABLE
const byte CMD_CONTROL_RST = 43    -- stepper controller IC reset

const byte CMD_WTCHDOG_DIS = 44    -- disabled watchdog
const byte CMD_WTCHDOG_ENA = 45    -- enable watchdog

const byte CMD_DIAGMODE    = 46    -- set diagnostic LED operating mode

const byte CMD_LASTVAL     = 46    -- last valid command for DOA
-- USB only commands
const byte CMD_IDENTIFY    = (CMD_LASTVAL+1)   -- USB only: send identification
const byte CMD_USB_DEBUG   = (CMD_LASTVAL+2)   -- USB only: enable debug output



-- =============================================================================
-- ** Application administration variables
-- =============================================================================

-- USB_DOA communication port selection (USB/DOA input jumper)
const byte USE_USB            = 0     -- jumper installed
const byte USE_DOA            = 1     -- no jumper installed
var   byte commPort                   -- selected port at startup

-- watchdog
var   byte wtchdogState               -- watchdog ENABLED/DISABLED flag
const byte WTCHDOG_ENABLED    = 1
const byte WTCHDOG_DISABLED   = 0
var   word wtchdogDelayValue          -- set watchdog timeout value

-- stepper variables
var   byte useHomeSensor[4]           -- flag: home sensor used @ init
var   byte homeSensorActiveLevel[4]   -- home sensor active state
var   byte motorHomeStatus[4]         -- flag: motor home status
const byte HOME_STS_NOT_HOMED = 0
const byte HOME_STS_HOMING    = 1
const byte HOME_STS_HOMED     = 2
--
var   byte motorSelectedForAbsPos     -- motor id for absolute position
var   byte motorSelectedForMaxStp     -- motor id for max step range
var   byte motorSelectedForAccDec     -- motor id for user-defined acc/dec table


include delay
include timer0_isr_interval    -- timer0 for interval ticks
include ustep-usec             -- timer3: usecs since power-up
include ustep-doa              -- PHCC DOA receiver routine
include ustep-usb              -- USB handler
include ustep-watchdog         -- communication watchdog
include ustep-led              -- DIAG LED routines
include ustep-x27              -- X27 stepper functions
include ustep-code             -- process received commands


-- =============================================================================
-- START OF microStepper INTERFACE PROGRAM
-- =============================================================================

BSR = 0                        -- set bank select register to default
INTCON_GIE = FALSE             -- disable all interrupts
enable_digital_io()            -- all I/O pins set to digital
INTCON = 0                     -- all interrupts disabled

initDOA()                                 -- init DOA communication variables
initUSB()                                 -- init USB communication variables
initDiagLED()                             -- init DIAG LED

initController()        -- init stepper controller IC & L293 drivers disabled
resetController()       -- reset stepper controller IC
initX27data()           -- init X27 stepper administration

-- NOTE: L293 stepper driver outputs are disabled :: motors not engaged!
--       Driver outputs enable must be one of the first commands issued if
--       larger stepper motors are used that require the L293 driver.
--       The X27 steppers are directly connected to the stepper crontroller IC.
--       Thus, when "only" using X27s, the L293 drivers can remain disabled.

initTimeSincePowerUp()         -- timer3 for precision time count since power-up
prevISRcounter    = 0          -- timer1 for 1 ms heartbeat and event waits

RCON_IPEN         = 0          -- disable priority levels on interrupts
INTCON2_INTEDG2   = 1          -- external INT2 interrupt on rising edge (DOA)
INTCON3_INT2IF    = 0          -- clear INT2 (DOA) interrupt flag
timer0_isr_init()              -- initialize timer0 (also enables interrupts)
INTCON_PEIE       = 1          -- enable unmasked peripheral interrupts
INTCON_GIE        = 1          -- enable unmasked interrupts


-- startup phase: set selected communication port and DIAG LED flash rate
if (USB_DOA == USE_USB) then
    commPort       = USE_USB
    diagLEDuse     = DIAGLED_HEARTBEAT
    flashRate      = STARTUP_FLASHRATE
    chkUSBconnect  = TRUE
    disableWatchdog()                   -- USB: DEFAULT watchdog disabled
    INTCON3_INT2IE = 0                  -- disable INT2 (DOA) external interrupt
else
    commPort       = USE_DOA
    diagLEDuse     = DIAGLED_HEARTBEAT
    flashRate      = DOA_RESET_RATE     -- indicate initial 1 sec delay
    chkUSBconnect  = FALSE
    enableWatchdog()                    -- DOA: DEFAULT watchdog enabled
    INTCON3_INT2IE = 1                  -- enable INT2 (DOA) external interrupt
end if

-- watchdog
wtchdogDelayValue = WTCHDOG_DFLT_TIMEOUT       -- initialize watchdog
commRestartWatchdog()                          -- start comm protocol watchdog
set_delay(HEARTBEAT_SLOT, flashRate)           -- start heartbeat blinking
    
initMotorStatus()      -- no motor homed, motor selected for ABSpos update: none

forever loop
  -- for PHCC, the DOA communication can start immediately.
  -- for USB, first there is a check that the USB connection is established.

  if (chkUSBconnect == TRUE) then
     -- check periodically for USB connection active
     diagLEDheartBeat()                                  ; update DIAG LED state
     if (isr_counter != prevISRcounter) then
        -- one (or more) timer tick elapsed
        prevISRcounter = isr_counter
--      if (usb_cdc_line_status() != 0x00) then          ; check_comm_active()
        if (VsenseIN) then                               ; check_comm_active()
           chkUSBconnect = FALSE
           -- USB connection established: setup USB serial library
           usb_serial_init()
           flashRate = USB_FLASH_RATE
        end if
     end if
  else
     -- main loop: startup phase for USB done -- OR -- PHCC DOA selected
    if (commPort == USE_USB) then
       -- USB communication
       --     keep checking whether USB is still connected!
--     if (usb_cdc_line_status() != 0x00) then
       if (VsenseIN) then
          handleUSBcommunication()
          if (USBcmdReceived == TRUE) then
             USBcmdReceived = FALSE
             commandCode = USBrxByte1
             commandData = USBrxByte2
             if (diagLEDuse == DIAGLED_MSG_ACK) then  DIAGLED = !DIAGLED  end if
             processCommand()
          end if
       else
          -- USB connection lost -> restart USB connection setup loop
          chkUSBconnect  = TRUE
          flashRate      = STARTUP_FLASHRATE
          diagLEDuse     = DIAGLED_HEARTBEAT  -- make sure the DIAG LED flashes
          prevISRcounter = 0
       end if
    else
       -- PHCC DOA communication
       -- ignore "possible garbage" at power up
       if (flashRate != DOA_RESET_RATE) then
          if (DOAcmdReceived == TRUE) then
             DOAcmdReceived = FALSE
             commandCode = subaddress
             commandData = databyte
             if (diagLEDuse == DIAGLED_MSG_ACK) then  DIAGLED = !DIAGLED  end if
             processCommand()
          end if
       end if
    end if

    -- execute continuously running actions (if required)
    diagLEDheartBeat()          ; update DIAG LED state if in "heart beat" mode
    commCheckWatchdog()         ; check communication protocol watchdog
    updStepperPosition()        ; update all motor setpoints (one step per call)
    executeHoming()             ; motor homing (if needed/requested)

-- TEST ========================================================================
-- simple test program for stepper #4 - just like Guy's first test program
-- Using motor #4, because that is default displayed on the MOTOR output LEDs.
-- NOTE: DIAG LED, watchdog, and DOA/USB communication is *not* working here!
--
--   var word stepCount
--
--     DIRMOT4 = 0
--     stepCount = 0
--     forever loop
--         CLKMOT4 = 0
--         delay_1us()
--         stepCount = stepCount + 1
--         if (stepCount > 3780) then
--             DIRMOT4 = !DIRMOT4
--             stepCount = 0
--             delay_100ms(5)
--         end if
--         CLKMOT4 = 1
--         delay_10us(50)
--     end loop
-- TEST END ====================================================================

   end if
end loop


-- =============================================================================

-- Interrupt routine for the DOA serial communication.
-- As all defined interrupt routines are called whenever any interrupt occurs,
-- it is the responsibility of each interrupt routine to check if the
-- interrupt was "for him".

procedure interruptHandler is
  pragma INTERRUPT

  if ( INTCON3_INT2IF ) then
      processDOAinterrupt()
  end if
end procedure

